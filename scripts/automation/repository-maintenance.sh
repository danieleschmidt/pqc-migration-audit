#!/bin/bash
# Repository Maintenance Automation Script
# Performs regular maintenance tasks for the PQC Migration Audit repository

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
LOG_FILE="${REPO_ROOT}/logs/maintenance-$(date +%Y%m%d).log"
BACKUP_DIR="${REPO_ROOT}/backups"
MAX_LOG_DAYS=30
MAX_BACKUP_DAYS=90

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$LOG_FILE"
}

log_success() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] SUCCESS:${NC} $1" | tee -a "$LOG_FILE"
}

log_warning() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARNING:${NC} $1" | tee -a "$LOG_FILE"
}

log_error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR:${NC} $1" | tee -a "$LOG_FILE"
}

# Setup logging
setup_logging() {
    mkdir -p "$(dirname "$LOG_FILE")"
    log "Starting repository maintenance"
    log "Repository: $(git remote get-url origin)"
    log "Branch: $(git branch --show-current)"
    log "Commit: $(git rev-parse HEAD)"
}

# Cleanup old log files
cleanup_logs() {
    log "Cleaning up old log files"
    
    find "${REPO_ROOT}/logs" -name "maintenance-*.log" -mtime +${MAX_LOG_DAYS} -delete 2>/dev/null || true
    find "${REPO_ROOT}/logs" -name "*.log" -size +100M -delete 2>/dev/null || true
    
    log_success "Log cleanup completed"
}

# Cleanup temporary files
cleanup_temp_files() {
    log "Cleaning up temporary files"
    
    # Python cache files
    find "$REPO_ROOT" -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
    find "$REPO_ROOT" -name "*.pyc" -delete 2>/dev/null || true
    find "$REPO_ROOT" -name "*.pyo" -delete 2>/dev/null || true
    
    # Test artifacts
    rm -rf "$REPO_ROOT"/.pytest_cache 2>/dev/null || true
    rm -rf "$REPO_ROOT"/.coverage 2>/dev/null || true
    rm -rf "$REPO_ROOT"/htmlcov 2>/dev/null || true
    rm -f "$REPO_ROOT"/coverage.xml 2>/dev/null || true
    rm -f "$REPO_ROOT"/.coverage.* 2>/dev/null || true
    
    # Build artifacts
    rm -rf "$REPO_ROOT"/build 2>/dev/null || true
    rm -rf "$REPO_ROOT"/dist 2>/dev/null || true
    rm -rf "$REPO_ROOT"/*.egg-info 2>/dev/null || true
    
    # IDE files
    find "$REPO_ROOT" -name ".DS_Store" -delete 2>/dev/null || true
    find "$REPO_ROOT" -name "Thumbs.db" -delete 2>/dev/null || true
    
    # Temporary scan files
    find "$REPO_ROOT" -name "*.tmp" -mtime +1 -delete 2>/dev/null || true
    find "$REPO_ROOT" -name "tmp_*" -mtime +1 -delete 2>/dev/null || true
    
    log_success "Temporary file cleanup completed"
}

# Update dependencies
update_dependencies() {
    log "Checking for dependency updates"
    
    cd "$REPO_ROOT"
    
    # Check for outdated packages
    if command -v pip &> /dev/null; then
        pip list --outdated --format=json > outdated-packages.json 2>/dev/null || true
        
        if [ -s outdated-packages.json ]; then
            OUTDATED_COUNT=$(jq length outdated-packages.json 2>/dev/null || echo "0")
            if [ "$OUTDATED_COUNT" -gt 0 ]; then
                log_warning "Found $OUTDATED_COUNT outdated packages"
                
                # Create dependency update issue if many outdated packages
                if [ "$OUTDATED_COUNT" -gt 10 ] && command -v gh &> /dev/null; then
                    create_dependency_update_issue
                fi
            else
                log_success "All dependencies are up to date"
            fi
        fi
        
        rm -f outdated-packages.json
    fi
    
    # Check for security vulnerabilities
    if command -v safety &> /dev/null; then
        log "Running security check on dependencies"
        if safety check --json --output=security-report.json 2>/dev/null; then
            log_success "No security vulnerabilities found in dependencies"
        else
            log_warning "Security vulnerabilities found in dependencies"
            if command -v gh &> /dev/null; then
                create_security_issue
            fi
        fi
        rm -f security-report.json
    fi
}

# Create GitHub issue for dependency updates
create_dependency_update_issue() {
    if [ -z "${GITHUB_TOKEN:-}" ]; then
        log_warning "GITHUB_TOKEN not set, skipping issue creation"
        return
    fi
    
    local issue_title="🔄 Dependency Updates Required"
    local issue_body="## Automated Dependency Update Report

Multiple outdated dependencies detected during maintenance.

### Action Required
- Review outdated packages
- Update dependencies following security guidelines
- Test compatibility after updates

### Generated by
Repository maintenance automation on $(date)

/label enhancement dependencies"
    
    if gh issue create --title "$issue_title" --body "$issue_body" --label "dependencies,automation" 2>/dev/null; then
        log_success "Created dependency update issue"
    else
        log_warning "Failed to create dependency update issue"
    fi
}

# Create GitHub issue for security vulnerabilities
create_security_issue() {
    if [ -z "${GITHUB_TOKEN:-}" ]; then
        log_warning "GITHUB_TOKEN not set, skipping security issue creation"
        return
    fi
    
    local issue_title="🚨 Security Vulnerabilities in Dependencies"
    local issue_body="## Security Alert

Security vulnerabilities detected in project dependencies.

### Action Required
- Review security report
- Update vulnerable dependencies immediately
- Run full security scan after updates

### Priority
This issue requires immediate attention.

### Generated by
Repository maintenance automation on $(date)

/label security critical"
    
    if gh issue create --title "$issue_title" --body "$issue_body" --label "security,critical" 2>/dev/null; then
        log_success "Created security vulnerability issue"
    else
        log_warning "Failed to create security issue"
    fi
}

# Backup important files
backup_repository_data() {
    log "Creating repository backup"
    
    mkdir -p "$BACKUP_DIR"
    
    local backup_file="$BACKUP_DIR/repo-backup-$(date +%Y%m%d_%H%M%S).tar.gz"
    
    # Create backup excluding large/temporary files
    tar -czf "$backup_file" \
        --exclude='.git' \
        --exclude='__pycache__' \
        --exclude='*.pyc' \
        --exclude='node_modules' \
        --exclude='.pytest_cache' \
        --exclude='htmlcov' \
        --exclude='dist' \
        --exclude='build' \
        --exclude='*.egg-info' \
        --exclude='logs' \
        --exclude='backups' \
        -C "$REPO_ROOT" . 2>/dev/null || {
        log_error "Failed to create backup"
        return 1
    }
    
    # Verify backup was created
    if [ -f "$backup_file" ]; then
        local backup_size=$(du -h "$backup_file" | cut -f1)
        log_success "Backup created: $backup_file ($backup_size)"
        
        # Cleanup old backups
        find "$BACKUP_DIR" -name "repo-backup-*.tar.gz" -mtime +${MAX_BACKUP_DAYS} -delete 2>/dev/null || true
        log "Cleaned up backups older than $MAX_BACKUP_DAYS days"
    else
        log_error "Backup file not created"
        return 1
    fi
}

# Check repository health
check_repository_health() {
    log "Checking repository health"
    
    cd "$REPO_ROOT"
    
    # Check Git repository integrity
    if git fsck --no-progress &>/dev/null; then
        log_success "Git repository integrity check passed"
    else
        log_error "Git repository integrity check failed"
    fi
    
    # Check for large files
    local large_files=$(find . -type f -size +50M 2>/dev/null | grep -v ".git" | head -10)
    if [ -n "$large_files" ]; then
        log_warning "Large files detected:"
        echo "$large_files" | while read -r file; do
            log_warning "  $(du -h "$file" | cut -f1) - $file"
        done
    fi
    
    # Check disk usage
    local disk_usage=$(du -sh . 2>/dev/null | cut -f1)
    log "Repository size: $disk_usage"
    
    # Check for uncommitted changes
    if ! git diff --quiet || ! git diff --cached --quiet; then
        log_warning "Uncommitted changes detected"
    else
        log_success "Working directory is clean"
    fi
    
    # Check branch status
    local current_branch=$(git branch --show-current)
    local remote_branch="origin/$current_branch"
    
    if git rev-list --count "$current_branch..$remote_branch" &>/dev/null; then
        local behind_count=$(git rev-list --count "$current_branch..$remote_branch")
        if [ "$behind_count" -gt 0 ]; then
            log_warning "Branch is $behind_count commits behind $remote_branch"
        fi
    fi
    
    if git rev-list --count "$remote_branch..$current_branch" &>/dev/null; then
        local ahead_count=$(git rev-list --count "$remote_branch..$current_branch")
        if [ "$ahead_count" -gt 0 ]; then
            log_warning "Branch is $ahead_count commits ahead of $remote_branch"
        fi
    fi
}

# Run automated tests
run_automated_tests() {
    log "Running automated tests"
    
    cd "$REPO_ROOT"
    
    # Run linting if available
    if command -v flake8 &> /dev/null; then
        log "Running code linting"
        if flake8 src/ tests/ --max-line-length=120 --extend-ignore=E203,W503 2>/dev/null; then
            log_success "Code linting passed"
        else
            log_warning "Code linting found issues"
        fi
    fi
    
    # Run type checking if available
    if command -v mypy &> /dev/null; then
        log "Running type checking"
        if mypy src/ --ignore-missing-imports 2>/dev/null; then
            log_success "Type checking passed"
        else
            log_warning "Type checking found issues"
        fi
    fi
    
    # Run security linting if available
    if command -v bandit &> /dev/null; then
        log "Running security analysis"
        if bandit -r src/ -ll 2>/dev/null; then
            log_success "Security analysis passed"
        else
            log_warning "Security analysis found issues"
        fi
    fi
    
    # Run unit tests if available
    if command -v pytest &> /dev/null && [ -d "tests" ]; then
        log "Running unit tests"
        if pytest tests/ -q --tb=short --maxfail=5 --timeout=300 2>/dev/null; then
            log_success "Unit tests passed"
        else
            log_warning "Unit tests failed or had issues"
        fi
    fi
}

# Update documentation
update_documentation() {
    log "Updating documentation"
    
    cd "$REPO_ROOT"
    
    # Update README badges if possible
    if [ -f "README.md" ]; then
        local readme_updated=false
        
        # Update last updated date
        if grep -q "Last updated:" README.md; then
            sed -i.bak "s/Last updated:.*/Last updated: $(date +%Y-%m-%d)/" README.md
            readme_updated=true
        fi
        
        # Clean up backup file
        rm -f README.md.bak
        
        if [ "$readme_updated" = true ]; then
            log_success "README.md updated"
        fi
    fi
    
    # Generate API documentation if tools available
    if command -v sphinx-build &> /dev/null && [ -d "docs" ]; then
        log "Building documentation"
        if make -C docs html &>/dev/null; then
            log_success "Documentation built successfully"
        else
            log_warning "Documentation build failed"
        fi
    fi
}

# Check for security issues
security_check() {
    log "Running comprehensive security check"
    
    cd "$REPO_ROOT"
    
    # Check for secrets in repository
    if command -v git-secrets &> /dev/null; then
        log "Scanning for secrets"
        if git secrets --scan 2>/dev/null; then
            log_success "No secrets found in repository"
        else
            log_warning "Potential secrets detected"
        fi
    fi
    
    # Check file permissions
    log "Checking file permissions"
    local suspicious_perms=$(find . -type f -perm -002 ! -path "./.git/*" 2>/dev/null | head -10)
    if [ -n "$suspicious_perms" ]; then
        log_warning "World-writable files detected:"
        echo "$suspicious_perms" | while read -r file; do
            log_warning "  $file"
        done
    else
        log_success "File permissions check passed"
    fi
    
    # Check for suspicious files
    local suspicious_files=$(find . -name "*.exe" -o -name "*.bat" -o -name "*.cmd" | grep -v ".git" | head -10)
    if [ -n "$suspicious_files" ]; then
        log_warning "Potentially suspicious files detected:"
        echo "$suspicious_files" | while read -r file; do
            log_warning "  $file"
        done
    fi
}

# Generate maintenance report
generate_report() {
    log "Generating maintenance report"
    
    local report_file="$REPO_ROOT/maintenance-report-$(date +%Y%m%d).md"
    
    cat > "$report_file" << EOF
# Repository Maintenance Report

**Date:** $(date +'%Y-%m-%d %H:%M:%S %Z')
**Repository:** $(git remote get-url origin 2>/dev/null || echo "Unknown")
**Branch:** $(git branch --show-current 2>/dev/null || echo "Unknown")
**Commit:** $(git rev-parse HEAD 2>/dev/null || echo "Unknown")

## Maintenance Tasks Completed

### ✅ Completed Tasks
EOF
    
    # Add task results to report
    if grep -q "SUCCESS" "$LOG_FILE"; then
        echo "" >> "$report_file"
        grep "SUCCESS:" "$LOG_FILE" | sed 's/.*SUCCESS: /- /' >> "$report_file"
    fi
    
    cat >> "$report_file" << EOF

### ⚠️ Warnings
EOF
    
    if grep -q "WARNING" "$LOG_FILE"; then
        echo "" >> "$report_file"
        grep "WARNING:" "$LOG_FILE" | sed 's/.*WARNING: /- /' >> "$report_file"
    else
        echo "- No warnings" >> "$report_file"
    fi
    
    cat >> "$report_file" << EOF

### ❌ Errors
EOF
    
    if grep -q "ERROR" "$LOG_FILE"; then
        echo "" >> "$report_file"
        grep "ERROR:" "$LOG_FILE" | sed 's/.*ERROR: /- /' >> "$report_file"
    else
        echo "- No errors" >> "$report_file"
    fi
    
    cat >> "$report_file" << EOF

## Repository Statistics

- **Size:** $(du -sh . 2>/dev/null | cut -f1)
- **Files:** $(find . -type f | wc -l)
- **Last commit:** $(git log -1 --format="%h - %s (%cr)" 2>/dev/null || echo "Unknown")

## Next Maintenance

Scheduled for: $(date -d "+7 days" +'%Y-%m-%d')

---
*Generated by automated repository maintenance*
EOF
    
    log_success "Maintenance report generated: $report_file"
    
    # Display summary
    echo ""
    echo "=== MAINTENANCE SUMMARY ==="
    local success_count=$(grep -c "SUCCESS:" "$LOG_FILE" || echo "0")
    local warning_count=$(grep -c "WARNING:" "$LOG_FILE" || echo "0")
    local error_count=$(grep -c "ERROR:" "$LOG_FILE" || echo "0")
    
    echo "✅ Successful tasks: $success_count"
    echo "⚠️  Warnings: $warning_count"
    echo "❌ Errors: $error_count"
    echo ""
    echo "📄 Full log: $LOG_FILE"
    echo "📊 Report: $report_file"
}

# Main maintenance function
main() {
    local start_time=$(date +%s)
    
    # Change to repository root
    cd "$REPO_ROOT"
    
    setup_logging
    
    # Run maintenance tasks
    cleanup_logs
    cleanup_temp_files
    backup_repository_data
    check_repository_health
    update_dependencies
    run_automated_tests
    update_documentation
    security_check
    
    # Generate final report
    generate_report
    
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    
    log "Maintenance completed in ${duration} seconds"
    
    # Exit with appropriate code
    if grep -q "ERROR:" "$LOG_FILE"; then
        log_error "Maintenance completed with errors"
        exit 1
    elif grep -q "WARNING:" "$LOG_FILE"; then
        log_warning "Maintenance completed with warnings"
        exit 0
    else
        log_success "Maintenance completed successfully"
        exit 0
    fi
}

# Handle script interruption
cleanup() {
    log "Maintenance script interrupted"
    exit 130
}

trap cleanup INT TERM

# Parse command line arguments
case "${1:-}" in
    --help|-h)
        echo "Repository Maintenance Script"
        echo ""
        echo "Usage: $0 [OPTIONS]"
        echo ""
        echo "Options:"
        echo "  --help, -h     Show this help message"
        echo "  --dry-run      Show what would be done without executing"
        echo "  --verbose      Enable verbose output"
        echo ""
        echo "This script performs automated maintenance tasks including:"
        echo "  - Cleanup of temporary files and logs"
        echo "  - Repository health checks"
        echo "  - Dependency updates"
        echo "  - Automated testing"
        echo "  - Security scanning"
        echo "  - Documentation updates"
        echo "  - Backup creation"
        exit 0
        ;;
    --dry-run)
        echo "DRY RUN MODE - No changes will be made"
        echo "Tasks that would be performed:"
        echo "  ✓ Cleanup temporary files"
        echo "  ✓ Check repository health"
        echo "  ✓ Check for dependency updates"
        echo "  ✓ Run automated tests"
        echo "  ✓ Security scanning"
        echo "  ✓ Update documentation"
        echo "  ✓ Create backup"
        echo "  ✓ Generate maintenance report"
        exit 0
        ;;
    --verbose)
        set -x
        main
        ;;
    "")
        main
        ;;
    *)
        echo "Unknown option: $1"
        echo "Use --help for usage information"
        exit 1
        ;;
esac